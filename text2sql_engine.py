"""
Text2SQL Engine using Google Gemini API
Converts natural language queries to SQL and executes them
"""

import google.generativeai as genai
import sqlite3
import re
import time
from typing import Optional, Dict, List, Tuple
from datetime import datetime

DB_PATH = "south_park_commons_members.db"
MAX_RETRIES = 3
RETRY_DELAY = 2  # seconds

class SchemaProvider:
    """Provides database schema context for LLM"""
    
    def __init__(self, db_path: str):
        self.db_path = db_path
    
    def get_schema_context(self) -> str:
        """Get database schema as formatted text"""
        
        schema = """
# DATABASE SCHEMA

## Table: members
- member_id (TEXT, PRIMARY KEY): Unique identifier for member
- uri (TEXT, UNIQUE): URI identifier
- first_name (TEXT): Member's first name
- last_name (TEXT): Member's last name
- bio (TEXT): Short bio/description
- title (TEXT): Current or primary title
- created_at (TIMESTAMP): Record creation timestamp

## Table: experiences
- experience_id (INTEGER, PRIMARY KEY): Auto-increment ID
- member_id (TEXT, FOREIGN KEY): References members.member_id
- company (TEXT): Company name (e.g., 'Stripe', 'Google', 'Amazon')
- role (TEXT): Job title (e.g., 'Co-Founder', 'Software Engineer', 'Manager')
- industry (TEXT): Industry classification (e.g., 'FinTech', 'Internet', 'E-Learning')
- city (TEXT): City of work location (e.g., 'Bangalore', 'San Francisco')
- state (TEXT): State/Province (e.g., 'Karnataka', 'California')
- country (TEXT): Country (e.g., 'India', 'United States')
- from_date (DATE): Employment start date
- to_date (DATE): Employment end date (NULL if current)
- is_current (BOOLEAN): Whether this is current role (1=true, 0=false)
- description (TEXT): Role description and responsibilities
- company_size (TEXT): Company size bracket (e.g., '1-10', '201-500', '10001+')
- company_website (TEXT): Company website URL
- company_linkedin (TEXT): Company LinkedIn URL

## Table: education
- education_id (INTEGER, PRIMARY KEY): Auto-increment ID
- member_id (TEXT, FOREIGN KEY): References members.member_id
- degree (TEXT): Degree type (e.g., 'B.Tech', 'M.Sc', '12th board CBSE')
- institute (TEXT): University/college/school name
- course (TEXT): Field of study (e.g., 'Computer Science', 'Information Systems')
- from_date (DATE): Start date
- to_date (DATE): End date

## Table: domains
- domain_id (INTEGER, PRIMARY KEY): Auto-increment ID
- member_id (TEXT, FOREIGN KEY): References members.member_id
- domain_name (TEXT): Domain/area of interest (e.g., 'SaaS', 'AI & ML', 'Blockchain')

## Table: content
- content_id (INTEGER, PRIMARY KEY): Auto-increment ID
- member_id (TEXT, UNIQUE FOREIGN KEY): References members.member_id
- content_text (TEXT): Member's bio/introduction text

## Table: search_queries (Logging)
- query_id (INTEGER, PRIMARY KEY): Auto-increment ID
- original_query (TEXT): User's natural language query
- generated_sql (TEXT): SQL generated by Text2SQL
- results_count (INTEGER): Number of results returned
- execution_time_ms (INTEGER): Query execution time
- error_message (TEXT): Error message if query failed
- timestamp (TIMESTAMP): When query was executed

## Table: query_results (Logging)
- result_id (INTEGER, PRIMARY KEY): Auto-increment ID
- query_id (INTEGER, FOREIGN KEY): References search_queries.query_id
- member_id (TEXT, FOREIGN KEY): References members.member_id
- relevance_score (REAL): Relevance/ranking score

# BUSINESS RULES & PATTERNS

## Company Search
Query: "Who worked at [Company]?"
- JOIN members with experiences WHERE company = '[Company]'
- Use DISTINCT to avoid duplicates

## Location Search
Query: "Who is in [City/State/Country]?"
- Use experiences.city for city-level search
- Use experiences.state for state-level search
- Use experiences.country for country-level search

## Role/Title Search
Query: "Who are [Role]?" (e.g., "Who are founders?")
- Use LIKE operator: role LIKE '%founder%'
- Case-insensitive matching

## Domain Search
Query: "Who works on [Domain]?" (e.g., "Who works on AI?")
- JOIN members with domains WHERE domain_name LIKE '%[Domain]%'
- Case-insensitive matching

## Education Search
Query: "Who studied at [Institute]?" or "Who has [Degree]?"
- JOIN members with education WHERE institute LIKE '%[Institute]%'
- Or degree = '[Degree]'

## Temporal Search
Query: "Who worked at [Company] in [Year]?"
- YEAR(from_date) <= [Year] AND (to_date IS NULL OR YEAR(to_date) >= [Year])
- This means they were employed during that year

## Combined/Complex Queries
Query: "Founders in Bangalore working on AI"
- Multiple JOINs: members → experiences → domains
- Multiple WHERE conditions with AND/OR logic
- Use DISTINCT for final results

# IMPORTANT RULES

1. Always use DISTINCT to avoid duplicate members in results
2. Use LEFT JOIN when joining with experiences/education/domains (some members may not have all)
3. For company names, use exact match (company = '[exact_name]')
4. For text fields (role, institute, domain_name), use LIKE with % for fuzzy matching
5. Return member information: member_id, first_name, last_name, title
6. Include relevant details from the query (company, role, location, etc.)
7. Order results by first_name, last_name for consistency
8. Always write valid SQLite syntax
9. If query is ambiguous, use the most likely interpretation
10. Return at most 100 rows to prevent data overload

# SAMPLE QUERIES & EXPECTED SQL

Query: "Who worked at Stripe?"
SELECT DISTINCT m.member_id, m.first_name, m.last_name, m.title, e.company, e.role, e.city
FROM members m
LEFT JOIN experiences e ON m.member_id = e.member_id
WHERE e.company = 'Stripe'
ORDER BY m.first_name, m.last_name
LIMIT 100;

Query: "Who is a founder in Bangalore?"
SELECT DISTINCT m.member_id, m.first_name, m.last_name, m.title, e.role, e.city
FROM members m
LEFT JOIN experiences e ON m.member_id = e.member_id
WHERE e.role LIKE '%founder%' AND e.city = 'Bangalore'
ORDER BY m.first_name, m.last_name
LIMIT 100;

Query: "Who works on AI?"
SELECT DISTINCT m.member_id, m.first_name, m.last_name, m.title, d.domain_name
FROM members m
LEFT JOIN domains d ON m.member_id = d.member_id
WHERE d.domain_name LIKE '%AI%'
ORDER BY m.first_name, m.last_name
LIMIT 100;

Query: "Who studied at IIT Madras?"
SELECT DISTINCT m.member_id, m.first_name, m.last_name, m.title, e.institute
FROM members m
LEFT JOIN education e ON m.member_id = e.member_id
WHERE e.institute LIKE '%IIT Madras%'
ORDER BY m.first_name, m.last_name
LIMIT 100;
"""
        return schema
    
    def get_sample_data(self) -> str:
        """Get sample data from database"""
        
        try:
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            sample = "\n# SAMPLE DATA\n\n"
            
            # Members sample
            sample += "## Members (first 3)\n"
            cursor.execute("SELECT * FROM members LIMIT 3")
            for row in cursor.fetchall():
                sample += f"- {dict(row)}\n"
            
            # Experiences sample
            sample += "\n## Experiences (first 3)\n"
            cursor.execute("""
            SELECT m.first_name, m.last_name, e.company, e.role, e.city, e.country
            FROM members m
            LEFT JOIN experiences e ON m.member_id = e.member_id
            WHERE e.company IS NOT NULL LIMIT 3
            """)
            for row in cursor.fetchall():
                sample += f"- {dict(row)}\n"
            
            # Domains sample
            sample += "\n## Domains (first 5)\n"
            cursor.execute("SELECT DISTINCT domain_name FROM domains LIMIT 5")
            for row in cursor.fetchall():
                sample += f"- {row[0]}\n"
            
            conn.close()
            return sample
        
        except Exception as e:
            return f"\n# SAMPLE DATA\n(Could not retrieve: {str(e)})\n"

class Text2SQLEngine:
    """Generate SQL from natural language using Gemini API"""
    
    def __init__(self, api_key: str, db_path: str = DB_PATH):
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel('gemini-2.5-pro')
        self.db_path = db_path
        self.schema_provider = SchemaProvider(db_path)
    
    def generate_sql(self, user_query: str, retry_count: int = 0) -> Optional[str]:
        """
        Generate SQL from natural language query
        Retries on failure up to MAX_RETRIES times
        """
        
        if retry_count >= MAX_RETRIES:
            print(f"❌ Failed to generate SQL after {MAX_RETRIES} retries")
            return None
        
        try:
            # Build prompt
            schema_context = self.schema_provider.get_schema_context()
            sample_data = self.schema_provider.get_sample_data()
            
            prompt = f"""You are a SQL expert. Convert the following natural language query to a valid SQLite SQL query.

{schema_context}

{sample_data}

# USER QUERY
{user_query}

# INSTRUCTIONS
1. Generate ONLY the SQL query, nothing else
2. The SQL must be valid SQLite syntax
3. Use DISTINCT to avoid duplicate members
4. Use LIMIT 100 to avoid too many results
5. Return member information with relevant details
6. Do NOT include explanations or comments
7. Do NOT use markdown code blocks, just the raw SQL

# RESPONSE
Generate the SQL query:"""
            
            # Call Gemini API
            response = self.model.generate_content(prompt)
            sql = response.text.strip()
            
            # Clean up response (remove markdown if present)
            sql = sql.replace("```sql", "").replace("```", "").strip()
            
            # Basic validation
            if not sql or len(sql) < 10:
                print(f"⚠️  Invalid SQL generated, retrying... (attempt {retry_count + 1})")
                time.sleep(RETRY_DELAY)
                return self.generate_sql(user_query, retry_count + 1)
            
            # Check for SELECT statement
            if "SELECT" not in sql.upper():
                print(f"⚠️  SQL missing SELECT, retrying... (attempt {retry_count + 1})")
                time.sleep(RETRY_DELAY)
                return self.generate_sql(user_query, retry_count + 1)
            
            return sql
        
        except Exception as e:
            print(f"⚠️  Error generating SQL: {str(e)}, retrying... (attempt {retry_count + 1})")
            time.sleep(RETRY_DELAY)
            return self.generate_sql(user_query, retry_count + 1)
    
    def validate_sql(self, sql: str) -> bool:
        """Validate SQL syntax without executing"""
        
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute(f"EXPLAIN QUERY PLAN {sql}")
            conn.close()
            return True
        except Exception as e:
            print(f"❌ SQL Validation Error: {str(e)}")
            return False
    
    def execute_query(self, user_query: str, execution_time_ms: int = None) -> Tuple[Optional[List[Dict]], Optional[str], int]:
        """
        End-to-end: Generate SQL → Validate → Execute → Return results
        
        Returns:
            (results, generated_sql, execution_time_ms)
            results: List of dictionaries, or None if failed
            generated_sql: The SQL that was executed
            execution_time_ms: Execution time in milliseconds
        """
        
        print(f"\n{'='*60}")
        print(f"Query: {user_query}")
        print(f"{'='*60}")
        
        start_time = time.time()
        
        # Step 1: Generate SQL
        print("Step 1: Generating SQL...")
        sql = self.generate_sql(user_query)
        
        if not sql:
            print("❌ Failed to generate SQL")
            return None, None, 0
        
        print(f"Generated SQL:\n{sql}\n")
        
        # Step 2: Validate SQL
        print("Step 2: Validating SQL...")
        if not self.validate_sql(sql):
            print("❌ SQL validation failed")
            return None, sql, 0
        
        print("✓ SQL is valid\n")
        
        # Step 3: Execute SQL
        print("Step 3: Executing SQL...")
        try:
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            cursor.execute(sql)
            results = [dict(row) for row in cursor.fetchall()]
            
            conn.close()
            
            execution_time_ms = int((time.time() - start_time) * 1000)
            
            print(f"✓ Query executed successfully")
            print(f"✓ Results: {len(results)} rows")
            print(f"✓ Execution time: {execution_time_ms}ms\n")
            
            return results, sql, execution_time_ms
        
        except Exception as e:
            print(f"❌ Execution Error: {str(e)}")
            execution_time_ms = int((time.time() - start_time) * 1000)
            return None, sql, execution_time_ms

class QueryExecutor:
    """Execute queries and log results"""
    
    def __init__(self, api_key: str, db_path: str = DB_PATH):
        self.engine = Text2SQLEngine(api_key, db_path)
        self.db_path = db_path
    
    def execute_and_log(self, user_query: str) -> Dict:
        """Execute query, log it, and return results"""
        
        # Execute query
        results, generated_sql, execution_time_ms = self.engine.execute_query(user_query)
        
        # Prepare response
        response = {
            "success": results is not None,
            "query": user_query,
            "generated_sql": generated_sql,
            "results": results if results else [],
            "results_count": len(results) if results else 0,
            "execution_time_ms": execution_time_ms,
            "error_message": None
        }
        
        # If no results, still consider it successful (just no data)
        if results is not None and len(results) == 0:
            response["success"] = True
            response["message"] = "Query executed successfully but returned no results"
        
        # If failed, set error
        if results is None:
            response["success"] = False
            response["error_message"] = "Failed to generate or execute SQL query"
        
        # Log to database
        self._log_query(response)
        
        return response
    
    def _log_query(self, response: Dict):
        """Log query to search_queries table"""
        
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute("""
            INSERT INTO search_queries 
            (original_query, generated_sql, results_count, execution_time_ms, error_message, timestamp)
            VALUES (?, ?, ?, ?, ?, ?)
            """, (
                response["query"],
                response["generated_sql"],
                response["results_count"],
                response["execution_time_ms"],
                response["error_message"],
                datetime.now().isoformat()
            ))
            
            # Also log individual results
            if response["success"] and response["results"]:
                query_id = cursor.lastrowid
                
                for result in response["results"]:
                    member_id = result.get("member_id")
                    if member_id:
                        cursor.execute("""
                        INSERT INTO query_results (query_id, member_id)
                        VALUES (?, ?)
                        """, (query_id, member_id))
            
            conn.commit()
            conn.close()
            
            print("✓ Query logged to database")
        
        except Exception as e:
            print(f"⚠️  Warning: Could not log query - {str(e)}")

def main():
    """Example usage"""
    
    # Get API key
    # api_key = input("Enter your Gemini API key: ").strip()
    api_key = "AIzaSyBOouWbG7RN6fPgDu2vaUebz3vrYm0G4WU"
    
    if not api_key:
        print("❌ API key is required")
        return
    
    # Initialize executor
    executor = QueryExecutor(api_key, DB_PATH)
    
    # Example queries
    test_queries = [
        "Who worked at Stripe?",
        "Who are founders in Bangalore?",
        "Who works on AI & ML?",
        "Who studied at IIT Madras?"
    ]
    
    print("\n" + "="*60)
    print("TEXT2SQL ENGINE - TEST")
    print("="*60)
    
    for query in test_queries:
        response = executor.execute_and_log(query)
        
        print(f"\nResults: {response['results_count']} rows")
        if response["results"]:
            for result in response["results"][:3]:  # Show first 3
                print(f"  - {result.get('first_name')} {result.get('last_name')}")
        
        print("\n" + "-"*60)

if __name__ == "__main__":
    main()